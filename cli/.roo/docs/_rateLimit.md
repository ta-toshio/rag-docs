
## **✅ 方式1: トークンバケット方式（現在の設計）**
- **レート制限を厳格に守る（4000msごとに1リクエスト）**
- **リクエストが多い場合は待機し、1分間15回の制限を超えない**
- `minTime: 4000` を設定することで **リクエスト間隔を固定** できる

### **🌟 方式1のメリット**
✅ **制限超過の心配がない（確実に1分15回に制限）**  
✅ **コードがシンプルでミスが起きにくい**

### **⚠️ 方式1のデメリット**
❌ **API の応答が速くても、無駄な待機が発生する可能性がある**（例えば 2 秒で返ってきても 4 秒待つ）  
❌ **処理速度が API の制約に完全に依存する**

---

## **✅ 方式2: キューベースの管理（並列処理を許可）**
- **複数のリクエストを並列実行し、1分間15回の制限を守る**
- **応答速度に応じてリクエストを調整（APIが速ければ次のリクエストを早めに処理できる）**
- `reservoir: 15` を設定し、1分ごとにリクエスト可能数をリセット

### **🌟 方式2のメリット**
✅ **API の応答が速ければ、より高速に処理できる**  
✅ **並列処理を活用しつつ、1分15回の制限を超えないよう調整できる**

### **⚠️ 方式2のデメリット**
❌ **実装がやや複雑になる（リクエスト数の管理が必要）**  
❌ **短時間にリクエストが集中する可能性がある**（瞬間的に多くリクエストし、その後待機する状態が発生）

---

## **✅ 方式2の実装（キューベースの管理）**
```typescript
import Bottleneck from "bottleneck";

const limiter = new Bottleneck({
  reservoir: 15, // 1分間に15回のリクエストを許可
  reservoirRefreshAmount: 15, // 毎分リクエスト数をリセット
  reservoirRefreshInterval: 60 * 1000, // 1分ごとにリセット
  maxConcurrent: 5, // 最大5つのリクエストを並列実行
});

/**
 * APIリクエストをレートリミット付きで実行
 */
export async function rateLimitedRequest<T>(fn: (...args: any[]) => Promise<T>, ...args: any[]): Promise<T> {
  return limiter.schedule(() => fn(...args));
}
```
📌 **この実装では、短時間に 5 件ずつ処理しながら、1分間のリクエスト回数を超えないように調整できます。**

---

## **🌟 どちらの方式を採用する？**
### **✅ 方式1（トークンバケット方式）が向いている場合**
- **確実にリクエスト制限を超えたくない**
- **コードをシンプルに保ちたい**
- **少し遅くても問題ない**

### **✅ 方式2（キューベースの管理）が向いている場合**
- **API の応答速度に応じて処理を最適化したい**
- **可能な限り速く処理を終えたい**
- **並列実行しても問題ない設計ができる**
